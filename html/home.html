<!DOCTYPE html>
<html lang="en">

<!-- ═══════════════════════════════════════════════════════════════ -->
<!-- HEAD SECTION: Meta tags, stylesheets, fonts, icons -->
<!-- ═══════════════════════════════════════════════════════════════ -->
<head>
  <!-- PWA Manifest for installable app support -->
  <link rel="manifest" href="../js/manifest.json">
  
  <!-- Character encoding and viewport for responsive design -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Page title shown in browser tab -->
  <title>Study Planner – Home</title>
  
  <!-- External stylesheets (consider consolidating these 4 files) -->
 
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/task.css">
  <link rel="stylesheet" href="../css/classcard.css">
  <link rel="stylesheet" href="../css/loading.css">
  
  <!-- Google Fonts preconnect for better loading performance -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  
  <!-- Custom font: M PLUS Rounded 1c -->
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c&display=swap" rel="stylesheet">
  
  <!-- Material Design Icons for UI elements -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  
  <!-- Favicon displayed in browser tab -->
  <link rel="icon" type="image/png" href="../image/logo1.png">
  
  <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- INLINE STYLES: Calendar layout, animations, responsive design -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
  <style>
    /* Tab loading indicator */

    /* Main wrapper: Flex layout for calendar + schedule side-by-side (desktop) */
    .responsive-wrapper {
      display: flex;
      flex-direction: row;
      gap: 1rem;
      flex-wrap: nowrap;
      align-items: flex-start;
    }

    /* Calendar and task sections: Width and sizing rules */
    .calendar-card,
    .schedule-task-wrapper {
      min-width: 365px;
      min-width: 100%;  /* ⚠️ TRASH: Overwrites line above, remove first min-width */
      width: 100%;
      flex-shrink: 1;
    }

    /* Task wrapper: Column layout for stacking schedule + tasks vertically */
    .schedule-task-wrapper {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    /* Tablet/Desktop (768px+): Add margin-top spacing (purpose unclear - consider removing) */
    @media (min-width: 768px) {  
      .schedule-task-wrapper {
        margin-top: 31px;  /* ⚠️ TRASH: Magic number, no clear design reason */
      }
    }

    /* Tablet/Desktop (768px+): Wider layout with larger min-width */
    @media (min-width: 768px) {  
      .calendar-card,
      .schedule-task-wrapper {
        gap: 10px;  /* ⚠️ TRASH: Should be on .responsive-wrapper parent, not children */
        min-width: 600px;
      }
    }
    
    /* Mobile (below 768px): Stack layout vertically instead of side-by-side */
    @media (max-width: 768px) {
      .responsive-wrapper {
        flex-direction: column;
      }
    }
    
    /* Highlight style for selected calendar date */
    .selected-date {
      background-color: #2196F3;
      color: white;
      border-radius: 50%;
      padding: 5px;
    }

    /* Hide calendar dates beyond first week when collapsed */
    #calendarGrid.collapsed .dates-grid span:nth-child(n+8) {
      display: none;
    }

    /* Expand/collapse icon rotation animation */
    .expand-icon {
      cursor: pointer;
      transition: transform 0.3s ease;
    }

    .expand-icon.collapsed {
      transform: rotate(-180deg);
    }

    /* Loading bar animation: Simulates page loading progress */
    .loading-bar {
      height: 100%;
      width: 0%;
      background-color: #2196F3;
      animation: loadbar 2s infinite;
    }

    /* Loading bar keyframes: Smooth animation from 0% → 80% → 0% */
    @keyframes loadbar {
      0% {
        width: 0%;
      }
      50% {
        width: 80%;
      }
      100% {
        width: 0%;
      }
    }
    
    /* Calendar header: Month navigation controls */
    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* Navigation buttons: Previous/Next month controls */
    .nav-button {
      background: none;
      border: none;
      cursor: pointer;
      color: #3d8fcd;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s;
    }

    /* Hover state for nav buttons: Light background on hover */
    .nav-button:hover {
      background: #f0f0f0;
    }

    /* Icon size inside nav buttons */
    .nav-button .material-icons {
      font-size: 24px;
    }

    /* Loading screen styles */
    
  </style>
</head>

<!-- ═══════════════════════════════════════════════════════════════ -->
<!-- BODY: Main application content -->
<!-- ═══════════════════════════════════════════════════════════════ -->
<body>

  <!-- LOADING SCREEN: Shown on app startup (before authentication) -->
<div id="loadingScreen" style="position:fixed;top:0;left:0;width:100%;height:100%;background:#000;display:flex;justify-content:center;align-items:center;z-index:9999;">
  <!-- Loader will be injected here -->
</div>

  <!-- MAIN APPLICATION CONTAINER: Hidden until Firebase auth completes -->
  <div class="app-container" style="display: none;">
    
    <!-- HOME SECTION: Calendar + Schedule + Tasks layout -->
    <div class="content-section active" id="homeSection">
      <!-- Main page with responsive wrapper for desktop/mobile layout -->
      <div class="main-page" style="padding: 1rem;">
        <div class="responsive-wrapper">
          
          <!-- ═══════════════════════════════════════════ -->
          <!-- CALENDAR SECTION: Left side on desktop -->
          <!-- ═══════════════════════════════════════════ -->
          <div class="calendar-card">
            <!-- Calendar header with month navigation -->
            <div class="calendar-header">
              <!-- Previous month button -->
              <button class="nav-button" id="prevMonth">
                <span class="material-icons">chevron_left</span>
              </button>
              
              <!-- Current month/year display -->
              <h2 id="monthYear"></h2>
              
              <!-- Next month button -->
              <button class="nav-button" id="nextMonth">
                <span class="material-icons">chevron_right</span>
              </button>
            </div>

            <!-- Calendar grid: Days of week + date numbers -->
            <div class="calendar-grid" id="calendarGrid">
              <!-- Weekday headers (Sun-Sat) -->
              <div class="weekdays">
                <span>Sun</span><span>Mon</span><span>Tue</span>
                <span>Wed</span><span>Thu</span><span>Fri</span><span>Sat</span>
              </div>
              
              <!-- Date cells: Populated dynamically by JavaScript -->
              <div class="dates-grid" id="datesGrid"></div>
            </div>
          </div>

          <!-- ═══════════════════════════════════════════ -->
          <!-- SCHEDULE + TASKS SECTION: Right side on desktop -->
          <!-- ═══════════════════════════════════════════ -->
          <div class="schedule-task-wrapper">
            
            <!-- SCHEDULE CARD: Shows today's classes on selected date -->
            <div class="schedule-card">
              <div class="card-header">
                <h3><span class="material-icons">schedule</span>Schedule</h3>
              </div>
              <!-- Schedule items populated by JavaScript -->
              <div class="schedule-list" id="scheduleList"></div>
            </div>

            <!-- PENDING TASKS CARD: Shows upcoming tasks/assignments -->
            <div class="task-card">
              <div class="card-header">
                <h3><span class="material-icons">assignment</span>Pending Tasks</h3>
              </div>
              <!-- Task items populated by JavaScript -->
              <div class="task-list" id="pendingTasks"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>

   <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- CHATBOT FLOATING ACTION BUTTON: AI assistant for app help -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
 <div id="chatbot-fab" style="display: none;">
  <span class="material-icons">smart_toy</span>
</div>

  <!-- Chatbot window: Hidden by default, shown when FAB clicked -->
  <div id="chatbot-window" style="display:none;">
    <!-- Chatbot header with title and close button -->
    <div id="chatbot-header">
      <span style="font-weight:600;font-size:1.1rem;">T2S Chatbot</span>
      <span id="chatbot-close" class="material-icons">close</span>
    </div>

    <!-- Chatbot message display area -->
    <div id="messages"></div>

    <!-- Chatbot input section: Text input + send button -->
    <div id="chatbot-input-section">
      <input id="userInput" type="text" placeholder="Type a message...">
      <button id="chatbot-send">
        <span class="material-icons">send</span>
      </button>
    </div>
  </div>


  <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- TAB NAVIGATION: injected from components/tabbar.html -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
  <div id="tab-bar-container"></div>
  <script>
    (async function loadTabbar() {
      try {
        const res = await fetch('./components/tabsbar.html');
        const html = await res.text();
        const container = document.getElementById('tab-bar-container');
        container.innerHTML = html;

        // Execute any scripts included in the fetched fragment
        container.querySelectorAll('script').forEach(s => {
          const ns = document.createElement('script');
          if (s.src) ns.src = s.src; else ns.textContent = s.textContent;
          document.body.appendChild(ns);
          s.remove();
        });
      } catch (err) {
        console.error('Failed to load tab bar:', err);
      }
    })();
  </script>

  <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- EXTERNAL SCRIPTS: Firebase, utilities, main app logic -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
  
  <!-- Main app script file -->
  <script src="../js/script.js"></script>

  <!-- Firebase initialization module -->
  <script type="module" src="../js/firebase-init.js"></script>

  <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- MAIN APPLICATION LOGIC: Module imports + Firebase auth + Calendar -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
  <script type="module">
    // Firebase imports: Database and Authentication
    import { db, auth } from "../js/firebase-init.js";
    import { collection, query, orderBy, where, onSnapshot, getDocs  } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    
    // Expose auth (and db) to non-module scripts (chatbot code uses `auth`)
    // This prevents "auth is not defined" in non-module code like sendMessageToDialogflow
    window.auth = auth;
    window.db = db;

    // Chart.js imports: Bar chart visualization for statistics
    import { Chart, LinearScale, CategoryScale, BarController, BarElement } from 'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/+esm';
    // Register Chart.js components for use
    Chart.register(LinearScale, CategoryScale, BarController, BarElement);

    // Calendar state: Track current month/year being displayed
    let currentMonth = new Date().getMonth();
    let currentYear = new Date().getFullYear();

  /* ═══════════════════════════════════════════════════════════════ */
/* FIREBASE AUTH CHECK: Only show app if user is logged in */
/* ═══════════════════════════════════════════════════════════════ */
/* FIREBASE AUTH CHECK */
onAuthStateChanged(auth, async (user) => {
  if (user) {
    // User authenticated: Initialize app components
    await initializeCalendar(user);
    await loadPendingTasks(user);
    await checkUpcomingAlerts(user);
    await loadStatistics(user);
    
    // mark auth/data ready so other scripts can safely hide loader
    window._authFinished = true;

    // Hide loading screen and show main app UI
    hideLoadingScreen();
    
  } else {
    // No authenticated user: Redirect to login page
    window.location.href = 'login.html';
  }
});

/* Function to hide loading screen and show app */
function hideLoadingScreen() {
  const loadingScreen = document.getElementById('loadingScreen');
  const appContainer = document.querySelector('.app-container');
  const tabBar = document.querySelector('.tab-bar');
  const chatbotFab = document.getElementById('chatbot-fab');
  
  if (loadingScreen) loadingScreen.style.display = 'none';
  if (appContainer) appContainer.style.display = 'block';
  if (tabBar) tabBar.style.display = 'flex';
  if (chatbotFab) chatbotFab.style.display = 'flex';
  
  // Clear any fail-safe timeout
  if (window._clearLoaderFailSafe) window._clearLoaderFailSafe();
}

    /* ═══════════════════════════════════════════════════════════════ */
    /* CALENDAR INITIALIZATION: Set up month navigation listeners */
    /* ═══════════════════════════════════════════════════════════════ */
    async function initializeCalendar(user) {
      const calendarGrid = document.getElementById('calendarGrid');
      calendarGrid.classList.remove('collapsed');
      
      // Previous month button: Navigate backwards
      document.getElementById('prevMonth').addEventListener('click', () => {
        currentMonth--;
        if (currentMonth < 0) {
          currentMonth = 11;
          currentYear--;
        }
        renderCalendar(currentMonth, currentYear, user);
      });

      // Next month button: Navigate forwards
      document.getElementById('nextMonth').addEventListener('click', () => {
        currentMonth++;
        if (currentMonth > 11) {
          currentMonth = 0;
          currentYear++;
        }
        renderCalendar(currentMonth, currentYear, user);
      });

      // Initial render: Display current month/year
      await renderCalendar(currentMonth, currentYear, user);
    }

    /* ═══════════════════════════════════════════════════════════════ */
    /* RENDER CALENDAR: Draw calendar grid with dates and task dots */
    /* ═══════════════════════════════════════════════════════════════ */
    async function renderCalendar(month, year, user) {
      const monthYear = document.getElementById('monthYear');
      const datesGrid = document.getElementById('datesGrid');
      
      // Display month/year header (e.g., "November 2025")
      const date = new Date(year, month);
      monthYear.textContent = date.toLocaleString('default', { month: 'long', year: 'numeric' });
      
      // Clear previous calendar grid
      datesGrid.innerHTML = '';
      
      // Add blank cells for days before month starts (e.g., if month starts on Wednesday)
      const firstDow = new Date(year, month, 1).getDay();
      for (let i = 0; i < firstDow; i++) {
        const b = document.createElement('span');
        b.className = 'blank';
        datesGrid.appendChild(b);
      }

      // Get total days in month (e.g., 28-31)
      const dayCount = new Date(year, month + 1, 0).getDate();
      
      // Fetch user's tasks from Firebase to mark due dates with colored dots
      const taskDotColors = new Map();
      if (user && user.uid) {
        const taskQuery = query(collection(db, 'tasks'), where("userId", "==", user.uid));
        const taskSnapshot = await getDocs(taskQuery);
        
        taskSnapshot.forEach(doc => {
          const t = doc.data();
          // Convert Firebase timestamp to JavaScript Date
          const due = t.dueDate?.toDate ? t.dueDate.toDate() : new Date(t.dueDate);
          
          // Check if task is in current month being displayed
          if (due.getMonth() === month && due.getFullYear() === year) {
            const day = due.getDate();
            // Color code by task type: green=assignment, red=project, black=other
            const taskType = (t.type || "").toLowerCase();
            const color = 
              taskType === "assignment" ? "green" :
              taskType === "project" ? "red" : "black";
            taskDotColors.set(day, color);
          }
        });
      } else {
        console.warn("renderCalendar: User or user.uid is invalid for task query.");
      }

      // Create clickable date cells for each day in month
      for (let d = 1; d <= dayCount; d++) {
        const s = document.createElement('span');
        s.textContent = d;
        
        // Add colored dot if this date has a task due
        if (taskDotColors.has(d)) {
          const dot = document.createElement('div');
          const color = taskDotColors.get(d);
          dot.style.cssText = `
            width: 6px; height: 6px; background-color: ${color}; border-radius: 50%;
            position: absolute; bottom: 4px; left: 50%; transform: translateX(-50%);
          `;
          s.style.position = 'relative';
          s.appendChild(dot);
        }

        // Highlight today's date with blue background
        const today = new Date();
        if (d === today.getDate() && month === today.getMonth() && year === today.getFullYear()) {
          s.classList.add('selected-date');
          // Load today's schedule immediately
          showFor(d, month, year, user);
        }
        datesGrid.appendChild(s);
      }
      
      // Setup click handlers for each date to show schedule
      setupDateClickEvents(month, year, user);
    }

    /* ═══════════════════════════════════════════════════════════════ */
    /* LOAD PENDING TASKS: Fetch and display upcoming tasks from Firebase */
    /* ═══════════════════════════════════════════════════════════════ */
    /* LOAD PENDING TASKS */
async function loadPendingTasks(user) {
  if (!user || !user.uid) {
    console.error("loadPendingTasks: User or user.uid is invalid.");
    document.getElementById('pendingTasks').innerHTML = "<p style='text-align:center;color:red;'>Error: User not identified.</p>";
    return;
  }
  
  const pending = document.getElementById('pendingTasks');
  
  // Show loading text while fetching
  pending.innerHTML = '<div class="tab-loading">Fetching data...</div>';
  
  const q = query(
    collection(db, 'tasks'),
    where("userId", "==", user.uid),
    orderBy('dueDate')
  );
  
  return new Promise((resolve) => {
    let first = true;
    onSnapshot(q, (snapshot) => {
      if (snapshot.empty) {
        pending.innerHTML = "<p style='text-align:center;color:gray;'>No pending tasks.</p>";
      } else {
        pending.innerHTML = '';
        const now = new Date();

        snapshot.forEach(doc => {
          const t = doc.data();
          try {
            const due = t.dueDate?.toDate ? t.dueDate.toDate() : new Date(t.dueDate);

            if (due >= now) {
              const ti = document.createElement('div');
              const typeClass = t.type ? t.type.toLowerCase() : '';
              ti.className = `task-item ${typeClass}`;

              ti.innerHTML = `
                <div class="task-info">
                  <h4>${t.name}</h4>
                  <p>${t.description}</p>
                  <span class="deadline">Deadline: ${due.toLocaleDateString()}</span>
                </div>
              `;
              pending.appendChild(ti);
            }
          } catch (error) {
            console.error('Error processing task:', error);
          }
        });
      }
      
      if (first) {
        first = false;
        resolve();
      }
    }, (error) => {
      console.error("Error getting tasks:", error);
      pending.innerHTML = "<p style='text-align:center;color:red;'>Error loading tasks</p>";
      if (first) {
        first = false;
        resolve();
      }
    });
  });
}

    /* ═══════════════════════════════════════════════════════════════ */
    /* SETUP DATE CLICK EVENTS: Add click handlers to calendar dates */
    /* ═══════════════════════════════════════════════════════════════ */
    function setupDateClickEvents(month, year, user) {
      const datesGrid = document.getElementById('datesGrid');
      
      // Add click listener to each date cell
      datesGrid.querySelectorAll('span').forEach(s => {
        // Skip blank cells (days before month starts)
        if (!s.classList.contains('blank')) {
          s.addEventListener('click', () => {
            highlight(s);  // Highlight selected date with blue background
            // Load schedule for clicked date
            showFor(parseInt(s.textContent), month, year, user);
          });
        }
      });
    }

    /* ═══════════════════════════════════════════════════════════════ */
    /* HIGHLIGHT TODAY: Highlight and load schedule for system's today */
    /* ═══════════════════════════════════════════════════════════════ */
    function highlightToday() {
      const now = new Date();
      const datesGrid = document.getElementById('datesGrid');
      const todayNum = now.getDate();

      // Find and highlight today in the calendar grid (if visible)
      if (now.getMonth() === currentMonth && now.getFullYear() === currentYear) {
        const todaySpan = Array.from(datesGrid.children).find(ch => 
            !ch.classList.contains('blank') && parseInt(ch.textContent) === todayNum
        );
        if (todaySpan) {
            highlight(todaySpan);
        }
      }
      
      // Load schedule for system's current date
      if (auth.currentUser) {
        showFor(todayNum, now.getMonth(), now.getFullYear(), auth.currentUser);
      } else {
        console.warn("highlightToday: auth.currentUser is not available.");
      }
    }

    /* ═══════════════════════════════════════════════════════════════ */
    /* TIME FORMAT HELPER: Convert 24-hour format to 12-hour AM/PM */
    /* ═══════════════════════════════════════════════════════════════ */
    function to12HourFormat(hours, minutes) {
      const ampm = hours >= 12 ? 'PM' : 'AM';
      hours = hours % 12 || 12;
      return `${hours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
    }

    /* ═══════════════════════════════════════════════════════════════ */
    /* SHOW SCHEDULE FOR DATE: Load classes for selected calendar date */
    /* ═══════════════════════════════════════════════════════════════ */
    /* SHOW SCHEDULE FOR DATE */
async function showFor(dayNum, month, year, user) {
  const scheduleList = document.getElementById('scheduleList');
  clearSchedule();

  if (!user || !user.uid) {
    console.error("showFor called with invalid user object or uid:", user);
    scheduleList.innerHTML = "<p style='text-align:center;color:red;'>Error: User not identified for schedule.</p>";
    return;
  }

  // Show loading text while fetching
  scheduleList.innerHTML = '<div class="tab-loading">Fetching data...</div>';

  const sel = new Date(year, month, dayNum);
  const wd = sel.toLocaleString('en-US', { weekday: 'short' });

  const q = query(
    collection(db, 'classes'),
    where("userId", "==", user.uid),
    orderBy('time')
  );

  onSnapshot(q,
    (snapshot) => {
      let found = false;
      scheduleList.innerHTML = '';

      snapshot.forEach(doc => {
        const c = doc.data();
        const classDays = c.days.split(/,\s*/).map(d => d.substring(0, 3));
        
        if (classDays.includes(wd)) {
          found = true;
          
          const [startTime, endTime] = c.time.split(' - ');
          const [startHours, startMinutes] = startTime.split(':');
          const [endHours, endMinutes] = endTime.split(':');

          const timeRange = `${to12HourFormat(parseInt(startHours), parseInt(startMinutes))} – ${to12HourFormat(parseInt(endHours), parseInt(endMinutes))}`;

          const it = document.createElement('div');
          it.className = 'schedule-item';
          it.innerHTML = `
            <div class="time">${timeRange}</div>
            <div class="details">
              <h4>${c.name || 'Unnamed Class'}</h4>
              <p>${c.instructor || ''}</p>
            </div>
          `;
          scheduleList.appendChild(it);
        }
      });

      if (!found) {
        scheduleList.innerHTML = "<p style='text-align:center;color:gray;'>No classes on this day.</p>";
      }
    },
    (error) => {
      console.error("Error getting classes for showFor:", error);
      scheduleList.innerHTML = "<p style='text-align:center;color:red;'>Error loading schedule</p>";
    }
  );
}

    /* ═══════════════════════════════════════════════════════════════ */
    /* CLEAR SCHEDULE: Empty the schedule list */
    /* ═══════════════════════════════════════════════════════════════ */
    function clearSchedule() {
      const scheduleList = document.getElementById('scheduleList');
      scheduleList.innerHTML = '';
    }

    /* ═══════════════════════════════════════════════════════════════ */
    /* HIGHLIGHT: Add/remove selected-date class from calendar cells */
    /* ═══════════════════════════════════════════════════════════════ */
    function highlight(el) {
      // Remove highlight from previously selected date
      const selectedEl = document.querySelector('.selected-date');
      if (selectedEl) selectedEl.classList.remove('selected-date');
      // Add highlight to newly selected date
      el.classList.add('selected-date');
    }

   

    /* ═══════════════════════════════════════════════════════════════ */
    /* CHECK UPCOMING ALERTS: Notify user of classes/tasks within 2 hours */
    /* ═══════════════════════════════════════════════════════════════ */
    async function checkUpcomingAlerts(user) {
      // Guard: Verify user exists
      if (!user || !user.uid) {
        console.error("checkUpcomingAlerts: User or user.uid is invalid.");
        return;
      }
      
      const now = new Date();
      const twoHoursLater = new Date(now.getTime() + 2 * 60 * 60 * 1000);
      const nextDay = new Date(now.getTime() + 24 * 60 * 60 * 1000);

      // Query: Get all classes and tasks for this user
      const classQuery = query(collection(db, "classes"), where("userId", "==", user.uid));
      const taskQuery = query(collection(db, "tasks"), where("userId", "==", user.uid));

      let showAlert = false;
      let alertMessages = [];

      // Check for upcoming classes within 2 hours
      try {
        const classSnapshot = await getDocs(classQuery);
        classSnapshot.forEach(doc => {
          const c = doc.data();
          // Split class days and check if class is today
          const classDays = c.days.split(/,\s*/);
          const today = now.toLocaleString('en-US', { weekday: 'long' });

          if (classDays.includes(today)) {
            // Parse class start time (extract start portion before " - ")
            const startStr = c.time.split(" - ")[0];
            const [startH, startM] = startStr.split(":").map(Number);
            const classTime = new Date(now);
            classTime.setHours(startH, startM, 0, 0);

            // Alert if class starts within 2 hours
            if (classTime > now && classTime <= twoHoursLater) {
              alertMessages.push(`Upcoming class "${c.name}" starts at ${startStr}`);
              showAlert = true;
            }
          }
        });
      } catch (error) {
        console.error("Error checking upcoming classes:", error);
      }

      // Check for tasks due within 24 hours
      try {
        const taskSnapshot = await getDocs(taskQuery);
        taskSnapshot.forEach(doc => {
          const t = doc.data();
          const due = t.dueDate?.toDate ? t.dueDate.toDate() : new Date(t.dueDate);
          
          // Alert if task is due within 24 hours
          if (due > now && due <= nextDay) {
            alertMessages.push(`Task "${t.name}" is due soon (${due.toLocaleDateString()})`);
            showAlert = true;
          }
        });
      } catch (error) {
        console.error("Error checking upcoming tasks:", error);
      }

      // Show all collected alerts to user
      if (showAlert) {
        alertMessages.forEach(msg => showNotification(msg));
      }
    }

    /* ═══════════════════════════════════════════════════════════════ */
/* LOAD STATISTICS: Fetch data and render bar chart of study stats */
/* ═══════════════════════════════════════════════════════════════ */
async function loadStatistics(user) {
  if (!user || !user.uid) {
    console.error("loadStatistics: User or user.uid is invalid.");
    return;
  }
  
  const canvas = document.getElementById('myBarChart');
  if (!canvas) {
    console.warn("Statistics chart canvas not found in HTML");
    return;
  }

  const classesRef = query(collection(db, 'classes'), where("userId", "==", user.uid));
  const tasksRef = query(collection(db, 'tasks'), where("userId", "==", user.uid));

  const unsubs = [];
  // Return a promise that resolves after first chart is created
  return new Promise((resolve, reject) => {
    const classesUnsub = onSnapshot(classesRef, (classSnap) => {
      const tasksUnsub = onSnapshot(tasksRef, (taskSnap) => {
        try {
          const totalClasses = classSnap.size;
          const totalTasks = taskSnap.size;
          let completedTasks = 0;
          let pendingTasks = 0;
          taskSnap.forEach(doc => {
            const task = doc.data();
            task.completed ? completedTasks++ : pendingTasks++;
          });

          const ctx = canvas.getContext('2d');
          if (window.myChart && typeof window.myChart.destroy === 'function') {
            window.myChart.destroy();
          }

          window.myChart = new Chart(ctx, {
            type: 'bar',
            data: {
              labels: ['Classes', 'Total Tasks', 'Completed', 'Pending'],
              datasets: [{
                label: 'Study Statistics',
                data: [totalClasses, totalTasks, completedTasks, pendingTasks],
                backgroundColor: [
                  'rgba(78, 115, 223, 0.8)',
                  'rgba(54, 185, 204, 0.8)',
                  'rgba(28, 200, 138, 0.8)',
                  'rgba(246, 194, 62, 0.8)'
                ],
                borderWidth: 1
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: { legend: { display: false }, title: { display: true, text: 'Study Statistics', padding: 20 } },
              scales: {
                y: { beginAtZero: true, ticks: { stepSize: 1, precision: 0 }, grid: { display: true } },
                x: { grid: { display: false } }
              }
            }
          });

          // resolve after first successful chart draw
          resolve(() => {
            // cleanup function returned to caller if needed
            unsubs.forEach(u => u());
            if (window.myChart) window.myChart.destroy();
          });
        } catch (err) {
          console.error("Error creating statistics chart:", err);
          reject(err);
        }
      }, (error) => {
        console.error("Error fetching tasks for statistics:", error);
        reject(error);
      });
      unsubs.push(tasksUnsub);
    }, (error) => {
      console.error("Error fetching classes for statistics:", error);
      reject(error);
    });
    unsubs.push(classesUnsub);
  });
}
    /* ═══════════════════════════════════════════════════════════════ */
    /* SHOW NOTIFICATION: Display temporary toast notification to user */
    /* ═══════════════════════════════════════════════════════════════ */
    function showNotification(message) {
      // Get or create notification container
      const container = document.getElementById('alertBoxContainer');
      if (!container) {
        console.error("Alert box container not found!");
        return;
      }
      
      // Create notification box element
      const box = document.createElement('div');
      box.textContent = message;

      // Style notification with fade-in/fade-out animation
      box.style.cssText = `
        background-color: white; color: black; font-weight: bold;
        padding: 12px 16px; border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        font-size: 0.95rem; max-width: 300px;
        animation: fadein 0.3s ease, fadeout 0.5s ease 4.5s;
        opacity: 0; margin-bottom: 10px;
      `;

      // Fade in notification
      setTimeout(() => box.style.opacity = 1, 10);
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        box.style.opacity = 0;
        setTimeout(() => {
            if (container.contains(box)) {
                container.removeChild(box);
            }
        }, 500);
      }, 5000);

      // Add to notification container
      container.appendChild(box);
    }

  </script>

  <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- LOADING SCREEN TIMER: Handle first-time load vs login redirect -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
 <script>
  const loadingScreen = document.getElementById('loadingScreen');
  // keep initial UI elements hidden; auth handler will show them when ready
  const tabBar = document.querySelector('.tab-bar');
  const chatbotFab = document.getElementById('chatbot-fab');
  const appContainer = document.querySelector('.app-container');
  if (tabBar) tabBar.style.display = 'none';
  if (chatbotFab) chatbotFab.style.display = 'none';
  if (appContainer) appContainer.style.display = 'none';

  // Record that loader was shown (prevent repeated long animations)
  if (!sessionStorage.getItem('loaderShown')) {
    sessionStorage.setItem('loaderShown', 'true');
  }

  // Fail-safe: if auth never resolves, hide loader after 8s to avoid permanent block
  const failSafe = setTimeout(() => {
    if (loadingScreen) loadingScreen.style.display = 'none';
    if (appContainer) appContainer.style.display = 'block';
    if (tabBar) tabBar.style.display = 'flex';
    if (chatbotFab) chatbotFab.style.display = 'flex';
    console.warn('Loader hidden by fail-safe timeout');
  }, 8000);

  // Expose function so auth handler can clear the timeout when it hides the loader
  window._clearLoaderFailSafe = () => clearTimeout(failSafe);
</script>

  <!-- ensure loading screen doesn't re-block UI when tabs change -->
  <script>
    (function(){
      const loading = document.getElementById('loadingScreen');
      const app = document.querySelector('.app-container');
      const tabContainer = document.getElementById('tab-bar-container');

      // Force background white (avoid accidental dark overlay from other CSS)
      if (loading) loading.style.background = 'black';

      function hideLoading() {
        // Don't auto-hide loader when tab fragment injects unless user/auth is ready.
        if (!window._authFinished && !window.auth?.currentUser) {
          // keep loader visible until auth+data finish (fail-safe will still clear after timeout)
          return;
        }

        if (loading) loading.style.display = 'none';
        if (app) app.style.display = 'block';
        const tb = document.querySelector('.tab-bar');
        if (tb) tb.style.display = 'flex';
        const fab = document.getElementById('chatbot-fab');
        if (fab) fab.style.display = 'flex';

        // clear the fail-safe timeout so it doesn't run after we intentionally hid the loader
        window._clearLoaderFailSafe?.();
      }

      // Hide when tab fragment is clicked
      tabContainer?.addEventListener('click', (e) => {
        if (e.target.closest('a, button, .tab-item, .tab-link')) {
          hideLoading();
        }
      });

      // Listen for optional custom event other code might dispatch
      document.addEventListener('tab-change', hideLoading);

      // If the tab fragment is injected, ensure loading is hidden
      const mo = new MutationObserver((mutations) => {
        if (tabContainer && tabContainer.children.length) hideLoading();
      });
      if (tabContainer) mo.observe(tabContainer, { childList: true, subtree: true });

      // Expose helper for other scripts
      window.hideLoadingScreen = hideLoading;

    })();




    
    (async function loadLoader() {
    try {
      const res = await fetch('./components/loader.html');
      const html = await res.text();
      const container = document.getElementById('loadingScreen');
      container.innerHTML = html;
    } catch (err) {
      console.error('Failed to load loader:', err);
    }
  })();
  </script>
  <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- CHATBOT SCRIPT: Handle FAB interaction and message sending -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
  <script src="../js/chatbot.js"></script>


</body>

</html>
