<!DOCTYPE html>
<html lang="en">

<!-- ═══════════════════════════════════════════════════════════════ -->
<!-- HEAD SECTION: Meta tags, stylesheets, fonts, icons -->
<!-- ═══════════════════════════════════════════════════════════════ -->
<head>
  <!-- PWA Manifest for installable app support -->
  <link rel="manifest" href="../js/manifest.json">
  
  <!-- Character encoding and viewport for responsive design -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Page title shown in browser tab -->
  <title>Study Planner – Home</title>
  
  <!-- External stylesheets (consider consolidating these 4 files) -->
 
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/task.css">
  <link rel="stylesheet" href="../css/tasks.css">
  <link rel="stylesheet" href="../css/classes.css">
  <link rel="stylesheet" href="../css/classcard.css">
  <link rel="stylesheet" href="../css/loading.css">
  <link rel="stylesheet" href="../css/profile.css">
  
  <!-- Google Fonts preconnect for better loading performance -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  
  <!-- Custom font: M PLUS Rounded 1c -->
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c&display=swap" rel="stylesheet">
  
  <!-- Material Design Icons for UI elements -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  
  <!-- Favicon displayed in browser tab -->
  <link rel="icon" type="image/png" href="../image/logo1.png">
  
  <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- INLINE STYLES: Calendar layout, animations, responsive design -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
  <style>
    /* Tab loading indicator */

    /* Main wrapper: Flex layout for calendar + schedule side-by-side (desktop) */
    .responsive-wrapper {
      display: flex;
      flex-direction: row;
      gap: 1rem;
      flex-wrap: nowrap;
      align-items: flex-start;
    }

    /* Calendar and task sections: Width and sizing rules */
    .calendar-card,
    .schedule-task-wrapper {
      min-width: 100%;
      width: 100%;
      flex-shrink: 1;
    }

    /* Task wrapper: Column layout for stacking schedule + tasks vertically */
    .schedule-task-wrapper {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    

    /* Tablet/Desktop (768px+): Wider layout with larger min-width */
    @media (min-width: 768px) {
      .calendar-card,
      .schedule-task-wrapper {
        min-width: 600px;
      }
    }
    
    /* Mobile (below 768px): Stack layout vertically instead of side-by-side */
    @media (max-width: 768px) {
      .responsive-wrapper {
        flex-direction: column;
      }
    }
    
    /* Highlight style for selected calendar date */
    .selected-date {
      background-color: #2196F3;
      color: white;
      border-radius: 50%;
      padding: 5px;
    }


    /* Expand/collapse icon rotation animation */
    .expand-icon {
      cursor: pointer;
      transition: transform 0.3s ease;
    }

    .expand-icon.collapsed {
      transform: rotate(-180deg);
    }

    /* Loading bar animation: Simulates page loading progress */
    .loading-bar {
      height: 100%;
      width: 0%;
      background-color: #2196F3;
      animation: loadbar 2s infinite;
    }

    /* Loading bar keyframes: Smooth animation from 0% → 80% → 0% */
    @keyframes loadbar {
      0% {
        width: 0%;
      }
      50% {
        width: 80%;
      }
      100% {
        width: 0%;
      }
    }
    
    /* Calendar header: Month navigation controls */
    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* Navigation buttons: Previous/Next month controls */
    .nav-button {
      background: none;
      border: none;
      cursor: pointer;
      color: #3d8fcd;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s;
    }

    /* Hover state for nav buttons: Light background on hover */
    .nav-button:hover {
      background: #f0f0f0;
    }

    /* Icon size inside nav buttons */
    .nav-button .material-icons {
      font-size: 24px;
    }


    /* Loading screen styles */


  </style>
  <!-- OneSignal SDK with fallback handling -->
  <script>
    // OneSignal loading with error handling and fallback
    function loadOneSignalWithFallback() {
      // Set timeout for OneSignal loading
      const onesignalTimeout = setTimeout(() => {
        console.warn('OneSignal loading timeout - likely blocked by browser extension');
        setupFallbackNotifications();
      }, 5000);

      // Try to load OneSignal
      const script = document.createElement('script');
      script.src = 'https://cdn.onesignal.com/sdks/web/v16/OneSignalSDK.page.js';
      script.defer = true;

      script.onload = function() {
        clearTimeout(onesignalTimeout);
        console.log('OneSignal SDK loaded successfully');

        window.OneSignalDeferred = window.OneSignalDeferred || [];
        OneSignalDeferred.push(async function(OneSignal) {
          try {
            await OneSignal.init({
              appId: "ec449d4c-2a56-43a3-844a-9dbcb5a6de5f",
            });
            console.log('OneSignal initialized successfully');
            window.notificationSystem = 'onesignal';
          } catch (error) {
            console.error('OneSignal initialization failed:', error);
            setupFallbackNotifications();
          }
        });
      };

      script.onerror = function() {
        clearTimeout(onesignalTimeout);
        console.error('OneSignal SDK failed to load - likely blocked by browser extension');
        setupFallbackNotifications();
      };

      document.head.appendChild(script);
    }

    function setupFallbackNotifications() {
      console.log('Setting up fallback notification system');
      window.notificationSystem = 'fallback';

      // Check if browser supports notifications
      if ('Notification' in window) {
        // Request permission for fallback notifications
        function requestNotificationPermission() {
          if (Notification.permission === 'default') {
            Notification.requestPermission().then(function(permission) {
              if (permission === 'granted') {
                console.log('Fallback notification permission granted');
              }
            });
          }
        }

        // Request permission after a delay to avoid being too aggressive
        setTimeout(requestNotificationPermission, 3000);
      }

      // Store fallback notification function
      window.showFallbackNotification = function(title, options) {
        if ('Notification' in window && Notification.permission === 'granted') {
          return new Notification(title, options);
        } else {
          console.log('Fallback notification not shown - permission not granted');
          return null;
        }
      };
    }

    // Start loading OneSignal when page loads
    document.addEventListener('DOMContentLoaded', loadOneSignalWithFallback);
  </script>
</head>

<!-- ═══════════════════════════════════════════════════════════════ -->
<!-- BODY: Main application content -->
<!-- ═══════════════════════════════════════════════════════════════ -->
<body>



  <!-- LOADING SCREEN: Shown on app startup (before authentication) -->
<div id="loadingScreen" style="position:fixed;top:0;left:0;width:100%;height:100%;background:#000;display:flex;justify-content:center;align-items:center;z-index:9999;">
  <!-- Loader will be injected here -->
</div>


  <!-- MAIN APPLICATION CONTAINER: Hidden until Firebase auth completes -->
  <div class="app-container" style="display: none;">


  <!-- Confirmation Modal -->
  <div id="confirmModal" class="modal" style="display: none;">
    <div class="modal-content">
      <h3>Confirm Delete</h3>
      <p id="confirmMessage">Are you sure you want to delete this item?</p>
      <div class="modal-buttons">
        <button id="confirmYes" class="modal-btn yes-btn">Yes</button>
        <button id="confirmNo" class="modal-btn no-btn">No</button>
      </div>
    </div>
  </div>
    
    <!-- HOME SECTION: Calendar + Schedule + Tasks layout -->
    <div class="content-section active" id="homeSection">
      <!-- Main page with responsive wrapper for desktop/mobile layout -->
      <div class="main-page" style="padding: 0.2rem;">
        <div class="responsive-wrapper">
          
          <!-- ═══════════════════════════════════════════ -->
          <!-- CALENDAR SECTION: Left side on desktop -->
          <!-- ═══════════════════════════════════════════ -->
          <div class="calendar-card">
            <!-- Calendar header with month navigation -->
            <div class="calendar-header">
              <!-- Previous month button -->
              <button class="nav-button" id="prevMonth">
                <span class="material-icons">chevron_left</span>
              </button>
              
              <!-- Current month/year display -->
              <h2 id="monthYear"></h2>
              
              <!-- Next month button -->
              <button class="nav-button" id="nextMonth">
                <span class="material-icons">chevron_right</span>
              </button>
            </div>

            <!-- Calendar grid: Days of week + date numbers -->
            <div class="calendar-grid" id="calendarGrid">
              <!-- Weekday headers (Sun-Sat) -->
              <div class="weekdays">
                <span>Sun</span><span>Mon</span><span>Tue</span>
                <span>Wed</span><span>Thu</span><span>Fri</span><span>Sat</span>
              </div>

              <!-- Date cells: Populated dynamically by JavaScript -->
              <div class="dates-grid" id="datesGrid"></div>
            </div>
          </div>

          <!-- ═══════════════════════════════════════════ -->
          <!-- SCHEDULE + TASKS SECTION: Right side on desktop -->
          <!-- ═══════════════════════════════════════════ -->
          <div class="schedule-task-wrapper">
            
            <!-- SCHEDULE CARD: Shows today's classes on selected date -->
            <div class="schedule-card">
              <div class="card-header">
                <h3><span class="material-icons">schedule</span>Schedule</h3>
              </div>
              <!-- Schedule items populated by JavaScript -->
              <div class="schedule-list" id="scheduleList"></div>
            </div>

            <!-- PENDING TASKS CARD: Shows upcoming tasks/assignments -->
            <div class="task-card">
              <div class="card-header">
                <h3><span class="material-icons">assignment</span>Pending Tasks</h3>
              </div>
              <!-- Task items populated by JavaScript -->
              <div class="task-list" id="pendingTasks"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- TASKS SECTION (moved from tasks.html) -->
    <div class="content-section" id="tasksSection">
      <div class="full-task-card">
        <div class="card-header">
          <h3>
            <span class="material-icons">assignment</span>
            All Tasks
          </h3>
          <!-- FAB moved into header (RIGHT SIDE) -->
          <button id="addTaskFab" class="fab-header material-icons">add</button>
        </div>
        <div class="task-filters">
          <button id="showAll" class="filter-btn active">All</button>
          <button id="showAssignments" class="filter-btn">Assignments</button>
          <button id="showProjects" class="filter-btn">Projects</button>
          <button id="showDone" class="filter-btn">Done</button>
        </div>
        <div class="task-list" id="tasksList">
          <!-- Tasks will be loaded here from Firestore -->
        </div>
      </div>
    </div>

    <!-- DASHBOARD SECTION -->
    <div class="content-section" id="dashboardSection">
      <!-- Motivational Section -->
      <div class="motivational-section">
        <div class="quote-card">
          <blockquote id="dailyQuote">"The only way to do great work is to love what you do." - Steve Jobs</blockquote>
        </div>
      </div>

      <!-- Recent Activity Timeline -->
      <div class="activity-timeline">
        <h3>Recent Activity</h3>
        <div id="activityList" class="activity-list">
          <!-- Activities will be loaded here -->
        </div>
      </div>

      <div class="dashboard-grid">
        <!-- Circular Progress Cards -->
        <div class="circle-card">
          <div class="circle-progress" id="progressTasks">
            <span class="circle-value" id="progressTasksValue">0%</span>
          </div>
          <p class="circle-label">Task Completion</p>
        </div>

        <div class="circle-card">
          <div class="circle-progress" id="progressClasses">
            <span class="circle-value" id="progressClassesValue">0%</span>
          </div>
          <p class="circle-label">Classes Attended</p>
        </div>

        <!-- Square Stats -->
        <div class="stat-card">
          <h3>Total Tasks</h3>
          <span id="statTotalTasks">0</span>
        </div>

        <div class="stat-card">
          <h3>Completed Tasks</h3>
          <span id="statCompleted">0</span>
        </div>

        <div class="stat-card">
          <h3>Pending Tasks</h3>
          <span id="statPending">0</span>
        </div>

        <div class="stat-card">
          <h3>Total Classes</h3>
          <span id="statTotalClasses">0</span>
        </div>
      </div>
    </div>

    <!-- CLASSES SECTION (moved from classes.html) -->
    <div class="content-section" id="classesSection">
      <div class="full-class-card">
        <div class="card-header">
          <h3>
            <span class="material-icons">school</span>
            All Classes
          </h3>
          <!-- FAB moved into header (RIGHT SIDE) -->
          <button id="addClassFab" class="fab-header material-icons">add</button>
        </div>
        <div class="class-list" id="classesList">
          <!-- Classes will be loaded here from Firestore -->
        </div>
      </div>
    </div>




  
  <!-- PROFILE SECTION -->
<div class="content-section" id="profileSection">
  <div class="profile-container">
    <div class="profile-card">
      <div class="profile-header">
        <img id="userPhoto" src="../image/pfp.png" alt="Profile Picture">
        <h2 id="userName">Loading...</h2>
      </div>

      <div class="profile-info">
        <div class="info-row">
          <span class="material-icons">email</span>
          <input type="email" id="userEmail" disabled>
        </div>
        <div class="info-row">
          <span class="material-icons">school</span>
          <input type="text" id="userSchool" disabled>
        </div>
        <div class="info-row">
          <span class="material-icons">calendar_today</span>
          <input type="number" id="userAge" disabled>
        </div>
      </div>

      <div class="profile-buttons">
        <button class="logout-btn" id="logoutBtn">Log Out</button>
        <button class="delete-btn" id="deleteBtn">Delete</button>
      </div>
    </div>
  </div>
</div>

   <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- CHATBOT FLOATING ACTION BUTTON: AI assistant for app help -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
 <div id="chatbot-fab" style="display: none;">
  <span class="material-icons">smart_toy</span>
</div>

  <!-- Chatbot window: Hidden by default, shown when FAB clicked -->
  <div id="chatbot-window" style="display:none;">
    <!-- Chatbot header with title and close button -->
    <div id="chatbot-header">
      <span style="font-weight:600;font-size:1.1rem;">T2S Chatbot</span>
      <span id="chatbot-close" class="material-icons">close</span>
    </div>

    <!-- Chatbot message display area -->
    <div id="messages"></div>

    <!-- Chatbot input section: Text input + send button -->
    <div id="chatbot-input-section">
      <input id="userInput" type="text" placeholder="Type a message or use / commands (e.g., /add class)...">
      <button id="chatbot-send">
        <span class="material-icons">send</span>
      </button>
    </div>
  </div>


  <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- TAB NAVIGATION: injected from components/tabbar.html -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
<div id="tab-bar-container"></div>
<script>
  (async function loadTabbar() {
    try {
      const res = await fetch('./components/tabsbar.html');
      
      if (!res.ok) {
        throw new Error(`Failed to load tabbar: ${res.status} ${res.statusText}`);
      }
      
      const html = await res.text();
      const container = document.getElementById('tab-bar-container');
      
      if (!container) {
        throw new Error('Tab bar container not found');
      }
      
      container.innerHTML = html;

      // Execute scripts from the loaded HTML
      container.querySelectorAll('script').forEach(script => {
        const newScript = document.createElement('script');
        
        // Copy all attributes
        Array.from(script.attributes).forEach(attr => {
          newScript.setAttribute(attr.name, attr.value);
        });
        
        // Copy content if no src
        if (!script.src && script.textContent) {
          newScript.textContent = script.textContent;
        }
        
        document.body.appendChild(newScript);
        script.remove();
      });

      // Select home tab after loading
      setTimeout(() => {
        const homeBtn = document.querySelector('[data-target="homeSection"]');
        if (homeBtn && typeof homeBtn.click === 'function') {
          homeBtn.click();
        }
      }, 50);
      
    } catch (err) {
      console.error('Failed to load tab bar:', err);
      // You could show a fallback UI here if needed
    }
  })();
</script>
 
 

  <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- EXTERNAL SCRIPTS: Firebase, utilities, main app logic -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
  
  <!-- Main app script file -->


  <!-- Firebase initialization -->
  <script type="module" src="../js/firebase-init.js"></script>

  <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- MAIN APPLICATION LOGIC: Module imports + Firebase auth + Calendar -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
  <script type="module">
    // Firebase imports: Database and Authentication
    import { db, auth } from "../js/firebase-init.js";
    import { collection, query, orderBy, where, onSnapshot, getDocs, getDoc, updateDoc, deleteDoc, doc } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";
    import { onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
    
    // Expose auth (and db) to non-module scripts (chatbot code uses `auth`)
    // This prevents "auth is not defined" in non-module code like sendMessageToDialogflow
    window.auth = auth;
    window.db = db;

    // Chart.js imports: Bar chart visualization for statistics
    import { Chart, LinearScale, CategoryScale, BarController, BarElement } from 'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/+esm';
    // Register Chart.js components for use
    Chart.register(LinearScale, CategoryScale, BarController, BarElement);

    // Calendar state: Track current month/year being displayed
    let currentMonth = new Date().getMonth();
    let currentYear = new Date().getFullYear();

  /* ═══════════════════════════════════════════════════════════════ */
/* FIREBASE AUTH CHECK: Only show app if user is logged in */
/* ═══════════════════════════════════════════════════════════════ */
/* FIREBASE AUTH CHECK */
onAuthStateChanged(auth, async (user) => {
  if (user) {
    // User authenticated: Initialize app components
    await initializeCalendar(user);
    await loadPendingTasks(user);
    await checkUpcomingAlerts(user);
    await loadStatistics(user);
    initializeClassesSection(user);
    initializeTasksSection(user);
    initializeProfileSection(user);


    // mark auth/data ready so other scripts can safely hide loader
    window._authFinished = true;

    // Hide loading screen and show main app UI
    hideLoadingScreen();

  } else {
    // No authenticated user: Redirect to login page
    window.location.href = 'login.html';
  }
});

/* Function to hide loading screen and show app */
function hideLoadingScreen() {
  const loadingScreen = document.getElementById('loadingScreen');
  const appContainer = document.querySelector('.app-container');
  const tabBar = document.querySelector('.tab-bar');
  const chatbotFab = document.getElementById('chatbot-fab');
  
  if (loadingScreen) loadingScreen.style.display = 'none';
  if (appContainer) appContainer.style.display = 'block';
  if (tabBar) tabBar.style.display = 'flex';
  if (chatbotFab) chatbotFab.style.display = 'flex';
  
  // Clear any fail-safe timeout
  if (window._clearLoaderFailSafe) window._clearLoaderFailSafe();
}



 /* ═══════════════════════════════════════════════════════════════ */
  /* CLASSES SECTION LOGIC: Load and display all classes from Firestore */
  /* ═══════════════════════════════════════════════════════════════ */
  function initializeClassesSection(user) {
    const classesList = document.getElementById("classesList");

const displayClasses = (classes) => {
      classesList.innerHTML = "";

      if (!classes.length) {
        classesList.innerHTML = "<p style='text-align:center; color:gray;'>No classes found. Add your first class!</p>";
        return;
      }

 function getClassTimes(classData) {
  // Case 1: Single time string "4:00 PM - 6:00 PM"
  if (classData.time && classData.time.includes('-')) {
    const parts = classData.time.split('-').map(t => t.trim());
    return { start: parts[0], end: parts[1] };
  }
  
  // Case 2: Separate startTime and endTime fields
  if (classData.startTime && classData.endTime) {
    return { start: classData.startTime, end: classData.endTime };
  }
  
  // Case 3: Single time value (unlikely but handle it)
  if (classData.time) {
    return { start: classData.time, end: 'N/A' };
  }
  
  // Default fallback
  return { start: 'N/A', end: 'N/A' };
}

// Then update your display code
classes.forEach(d => {
  const div = document.createElement("div");
  div.className = "class-item";
  
  // Get times using our helper
  const { start, end } = getClassTimes(d);
  
  // Convert to 12-hour format
  const start12h = to12Hour(start);
  const end12h = to12Hour(end);

        div.innerHTML = `
          <div class="class-item-header">
            <div class="class-item-title">
              <h4>${d.name}</h4>
            </div>
            <button class="delete-btn" data-id="${d.id}">
              <span class="material-icons">delete</span>
            </button>
          </div>
          <div class="class-item-info">
            <div class="info-item">
              <span class="info-label">Days</span>
              <span class="info-value">${d.days}</span>
            </div>
            <div class="info-item">
              <span class="info-label">Time</span>
              <span class="info-value">${start12h} - ${end12h}</span>
            </div>
            <div class="info-item">
              <span class="info-label">Advisor</span>
              <span class="info-value">${d.instructor || 'N/A'}</span>
            </div>
          </div>
        `;

        classesList.appendChild(div);
      });

      // Delete button listeners using event delegation
      classesList.addEventListener("click", async (e) => {
        const btn = e.target.closest(".delete-btn");
        if (!btn) return;

        const id = btn.dataset.id;
        const modal = document.getElementById('confirmModal');
        const message = document.getElementById('confirmMessage');
        message.textContent = "Are you sure you want to delete this class?";
        modal.style.display = 'flex';

        // Remove existing event listeners to prevent duplicates
        const confirmYes = document.getElementById('confirmYes');
        const confirmNo = document.getElementById('confirmNo');

        const yesHandler = async () => {
          modal.style.display = 'none';
          try {
            await deleteDoc(doc(db, "classes", id));
            btn.closest(".class-item").remove();

            const cached = localStorage.getItem("classes");
            if (cached) {
              const updated = JSON.parse(cached).filter(cls => cls.id !== id);
              localStorage.setItem("classes", JSON.stringify(updated));
            }

            if (!classesList.children.length) {
              classesList.innerHTML = "<p style='text-align:center; color:gray;'>No classes found. Add your first class!</p>";
            }
            showNotification("Class deleted successfully");
          } catch (error) {
            showNotification("Failed to delete class. Please try again.");
          }
        };

        const noHandler = () => {
          modal.style.display = 'none';
        };

        // Remove previous listeners
        confirmYes.replaceWith(confirmYes.cloneNode(true));
        confirmNo.replaceWith(confirmNo.cloneNode(true));

        // Add new listeners
        document.getElementById('confirmYes').addEventListener('click', yesHandler);
        document.getElementById('confirmNo').addEventListener('click', noHandler);
      });
    };

    const loadClasses = async () => {
      const cached = localStorage.getItem("classes");
      if (cached) {
        try {
          const parsed = JSON.parse(cached);
          displayClasses(parsed);
        } catch (err) {
          console.warn("Failed to parse cached classes:", err);
        }
      }

      try {
        const q = query(
          collection(db, "classes"),
          where("userId", "==", user.uid)
        );

        onSnapshot(
          q,
          (snap) => {
            const classes = snap.docs.map(docSnap => ({
              ...docSnap.data(),
              id: docSnap.id
            }));

            displayClasses(classes);
            localStorage.setItem("classes", JSON.stringify(classes));

            // Store for offline notifications
            if (window.notificationManager) {
              window.notificationManager.storeScheduleData(user.uid, classes, []);
            }
          },
          (error) => {
            console.error("Real-time listener error:", error);
            classesList.innerHTML = `
              <p style="color: red; text-align: center; padding: 20px;">
                Connection error: ${error.message}
              </p>
            `;
          }
        );

      } catch (error) {
        console.error("Error loading classes:", error);
        classesList.innerHTML = `
          <p style="color: red; text-align: center; padding: 20px;">
            Error loading classes: ${error.message}
          </p>
        `;
      }
    };

 function to12Hour(t) {
  if (!t || t === 'N/A') return 'N/A';
  
  // If already in 12-hour format (like "6 PM"), return as-is
  if (t.includes('AM') || t.includes('PM')) {
    return t.trim();
  }
  
  try {
    // Handle 24-hour format (like "16:00")
    const [hours, minutes] = t.split(':').map(Number);
    const ampm = hours >= 12 ? 'PM' : 'AM';
    const displayHours = hours % 12 || 12;
    const displayMinutes = (minutes || 0).toString().padStart(2, '0');
    
    return `${displayHours}:${displayMinutes} ${ampm}`;
  } catch (e) {
    console.warn("Invalid time format:", t);
    return t; // Return original if we can't convert
  }
}

    loadClasses();
  }

  document.getElementById('addClassFab').addEventListener('click', () => {
    window.location.href = 'add-class.html';
  });




    /* ═══════════════════════════════════════════════════════════════ */
    /* CALENDAR INITIALIZATION: Set up month navigation listeners */
    /* ═══════════════════════════════════════════════════════════════ */
    async function initializeCalendar(user) {
      const calendarGrid = document.getElementById('calendarGrid');
      calendarGrid.classList.remove('collapsed');

      // Previous month button: Navigate backwards
      document.getElementById('prevMonth').addEventListener('click', () => {
        currentMonth--;
        if (currentMonth < 0) {
          currentMonth = 11;
          currentYear--;
        }
        renderCalendar(currentMonth, currentYear, user);
      });

      // Next month button: Navigate forwards
      document.getElementById('nextMonth').addEventListener('click', () => {
        currentMonth++;
        if (currentMonth > 11) {
          currentMonth = 0;
          currentYear++;
        }
        renderCalendar(currentMonth, currentYear, user);
      });

      // Initial render: Display current month/year
      await renderCalendar(currentMonth, currentYear, user);
    }

    /* ═══════════════════════════════════════════════════════════════ */
    /* RENDER CALENDAR: Draw calendar grid with dates and task dots */
    /* ═══════════════════════════════════════════════════════════════ */
    async function renderCalendar(month, year, user) {
      const monthYear = document.getElementById('monthYear');
      const datesGrid = document.getElementById('datesGrid');

      // Display month/year header (e.g., "November 2025")
      const date = new Date(year, month);
      monthYear.textContent = date.toLocaleString('default', { month: 'long', year: 'numeric' });

      // Clear previous calendar grid
      datesGrid.innerHTML = '';

      // Add blank cells for days before month starts (e.g., if month starts on Wednesday)
      const firstDow = new Date(year, month, 1).getDay();
      for (let i = 0; i < firstDow; i++) {
        const b = document.createElement('span');
        b.className = 'blank';
        datesGrid.appendChild(b);
      }

      // Get total days in month (e.g., 28-31)
      const dayCount = new Date(year, month + 1, 0).getDate();

      // Fetch user's tasks from Firebase to mark due dates with colored dots
      const taskDotColors = new Map();
      if (user && user.uid) {
        const taskQuery = query(collection(db, 'tasks'), where("userId", "==", user.uid));
        const taskSnapshot = await getDocs(taskQuery);

        taskSnapshot.forEach(doc => {
           const t = doc.data();
           // Convert Firebase timestamp to JavaScript Date
           const due = t.dueDate?.toDate ? t.dueDate.toDate() : new Date(t.dueDate);

           // Check if task is in current month being displayed and not completed
           if (!t.completed && due.getMonth() === month && due.getFullYear() === year) {
             const day = due.getDate();
             // Color code by task type: green=assignment, red=project, black=other
             const taskType = (t.type || "").toLowerCase();
             const color =
               taskType === "assignment" ? "#00b85f" :
               taskType === "project" ? "#ff0000" : "#000000";
             taskDotColors.set(day, color);
           }
          });
      } else {
        console.warn("renderCalendar: User or user.uid is invalid for task query.");
      }

      // Create clickable date cells for each day in month
      for (let d = 1; d <= dayCount; d++) {
        const s = document.createElement('span');
        s.textContent = d;

        // Add colored dot if this date has a task due
        if (taskDotColors.has(d)) {
          const dot = document.createElement('div');
          const color = taskDotColors.get(d);
          dot.style.cssText = `
            width: 6px; height: 6px; background-color: ${color}; border-radius: 50%;
            position: absolute; bottom: 4px; left: 50%; transform: translateX(-50%);
            border: 1px solid rgba(255, 255, 255, 0.3);
          `;
          s.style.position = 'relative';
          s.appendChild(dot);
        }

        // Highlight today's date with blue background
        const today = new Date();
        if (d === today.getDate() && month === today.getMonth() && year === today.getFullYear()) {
          s.classList.add('selected-date');
          // Load today's schedule immediately
          showFor(d, month, year, user);
        }
        datesGrid.appendChild(s);
      }

      // Setup click handlers for each date to show schedule
      setupDateClickEvents(month, year, user);
    }

    /* ═══════════════════════════════════════════════════════════════ */
    /* LOAD PENDING TASKS: Fetch and display upcoming tasks from Firebase */
    /* ═══════════════════════════════════════════════════════════════ */
    /* LOAD PENDING TASKS */
async function loadPendingTasks(user) {
  if (!user || !user.uid) {
    console.error("loadPendingTasks: User or user.uid is invalid.");
    document.getElementById('pendingTasks').innerHTML = "<p style='text-align:center;color:red;'>Error: User not identified.</p>";
    return;
  }
  
  const pending = document.getElementById('pendingTasks');
  
  // Show loading text while fetching
  pending.innerHTML = '<div class="tab-loading">Fetching data...</div>';
  
  const q = query(
    collection(db, 'tasks'),
    where("userId", "==", user.uid),
    orderBy('dueDate')
  );
  
  return new Promise((resolve) => {
    let first = true;
    onSnapshot(q, (snapshot) => {
      if (snapshot.empty) {
        pending.innerHTML = "<p style='text-align:center;color:gray;'>No pending tasks.</p>";
      } else {
        pending.innerHTML = '';
        const now = new Date();

        snapshot.forEach(doc => {
           const t = doc.data();
           try {
             const due = t.dueDate?.toDate ? t.dueDate.toDate() : new Date(t.dueDate);

             if (!t.completed && due >= now) {
               const ti = document.createElement('div');
               const typeClass = t.type ? t.type.toLowerCase() : '';
               ti.className = `task-item ${typeClass}`;
               ti.setAttribute('data-type', t.type || '');

               ti.innerHTML = `
                 <div class="task-info">
                   <h4>${t.name}</h4>
                   <p>${t.description}</p>
                   <span class="deadline">Deadline: ${due.toLocaleDateString()}</span>
                 </div>
               `;

               // Apply color based on task type
               const taskType = (t.type || "").toLowerCase();
               if (taskType === "assignment") {
                 ti.style.borderLeftColor = "#00b85f";
               } else if (taskType === "project") {
                 ti.style.borderLeftColor = "#ff0000";
               }

               pending.appendChild(ti);
             }
           } catch (error) {
             console.error('Error processing task:', error);
           }
         });
      }
      
      if (first) {
        first = false;
        resolve();
      }
    }, (error) => {
      console.error("Error getting tasks:", error);
      pending.innerHTML = "<p style='text-align:center;color:red;'>Error loading tasks</p>";
      if (first) {
        first = false;
        resolve();
      }
    });
  });
}




    /* ═══════════════════════════════════════════════════════════════ */
    /* TASKS SECTION LOGIC: Load and display all tasks from Firestore */
    

const tasksList = document.getElementById("tasksList");

  function initializeTasksSection(user) {
    if (!user) {
      window.location.href = 'login.html';
      return;
    }

    const displayTasks = (tasks) => {
      tasksList.innerHTML = "";

      if (!tasks.length) {
        tasksList.innerHTML = "<p style='text-align:center;color:gray;'>No tasks found. Start by adding one!</p>";
        return;
      }

      // Sort: unfinished first, then done
      tasks.sort((a, b) => {
        if (a.completed && !b.completed) return 1;
        if (!a.completed && b.completed) return -1;
        return 0;
      });

      tasks.forEach(task => {
        const dueDate = task.dueDate?.toDate ? task.dueDate.toDate() : new Date(task.dueDate);
        const options = {
          weekday: 'short',
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        };

        // Sanitize task type for CSS class names
        const sanitizedType = task.type ? task.type.toLowerCase().replace(/\s+/g, '-') : '';

        const div = document.createElement("div");
        div.className = `task-item ${sanitizedType}` + (task.completed ? " done" : "");
        div.setAttribute('data-type', task.type || '');

        div.innerHTML = `
          <div class="task-info">
            <h4 class="${sanitizedType}">${task.name}</h4>
            <p>${task.description}</p>
            <span class="deadline">Deadline: ${dueDate.toLocaleDateString('en-US', options)}</span>
          </div>
          <div class="task-actions">
            <button class="done-btn" ${task.completed ? "disabled" : ""}>${task.completed ? "Done!" : "Done"}</button>
            <button class="delete-btn" data-id="${task.id}">
              <span class="material-icons">delete</span>
            </button>
          </div>
        `;

        // Apply color based on task type
        const taskType = (task.type || "").toLowerCase();
        if (taskType === "assignment") {
          div.style.borderLeftColor = "#00b85f";
        } else if (taskType === "project") {
          div.style.borderLeftColor = "#ff0000";
        }

        tasksList.appendChild(div);
      });

      // Add event listeners for buttons using event delegation to prevent duplicates
      tasksList.addEventListener("click", async (e) => {
        const btn = e.target.closest(".done-btn, .delete-btn");
        if (!btn) return;

        if (btn.classList.contains("done-btn")) {
          const taskItem = btn.closest(".task-item");
          const id = taskItem.querySelector(".delete-btn").getAttribute("data-id");
          try {
            await updateDoc(doc(db, "tasks", id), { completed: true });
            taskItem.classList.add("done");
            btn.disabled = true;
            btn.textContent = "Done!";
            showNotification("Task marked as completed!");
          } catch (error) {
            showNotification("Failed to mark as done. Please try again.");
          }
        } else if (btn.classList.contains("delete-btn")) {
          const id = btn.getAttribute("data-id");
          const modal = document.getElementById('confirmModal');
          const message = document.getElementById('confirmMessage');
          message.textContent = "Are you sure you want to delete this task?";
          modal.style.display = 'flex';

          // Remove existing event listeners to prevent duplicates
          const confirmYes = document.getElementById('confirmYes');
          const confirmNo = document.getElementById('confirmNo');

          const yesHandler = async () => {
            modal.style.display = 'none';
            try {
              await deleteDoc(doc(db, "tasks", id));
              btn.closest(".task-item").remove();

              const cached = localStorage.getItem("tasks");
              if (cached) {
                const updated = JSON.parse(cached).filter(t => t.id !== id);
                localStorage.setItem("tasks", JSON.stringify(updated));
              }

              if (!tasksList.children.length) {
                tasksList.innerHTML = "<p style='text-align:center;color:gray;'>No tasks found. Start by adding one!</p>";
              }
              showNotification("Task deleted successfully");
            } catch (error) {
              console.error("Delete failed:", error);
              showNotification("Failed to delete task. Please try again.");
            }
          };

          const noHandler = () => {
            modal.style.display = 'none';
          };

          // Remove previous listeners
          confirmYes.replaceWith(confirmYes.cloneNode(true));
          confirmNo.replaceWith(confirmNo.cloneNode(true));

          // Add new listeners
          document.getElementById('confirmYes').addEventListener('click', yesHandler);
          document.getElementById('confirmNo').addEventListener('click', noHandler);
        }
      });
    };

    // Try to load from cache first
    const cached = localStorage.getItem("tasks");
    if (cached) {
      try {
        displayTasks(JSON.parse(cached));
      } catch (e) {
        console.warn("Invalid cache");
      }
    }

    // Set up real-time listener
    const q = query(
      collection(db, "tasks"),
      where("userId", "==", user.uid),
      orderBy("dueDate")
    );

    onSnapshot(q, (snapshot) => {
      const tasks = snapshot.docs.map(docSnap => ({
        ...docSnap.data(),
        id: docSnap.id
      }));
      displayTasks(tasks);
      localStorage.setItem("tasks", JSON.stringify(tasks));

      // Store for offline notifications
      if (window.notificationManager && window.auth?.currentUser) {
        window.notificationManager.storeScheduleData(window.auth.currentUser.uid, [], tasks);
      }
    }, (error) => {
      console.error("Error loading tasks:", error);
      tasksList.innerHTML = "<p style='text-align:center;color:red;'>Error loading tasks</p>";
    });

    document.getElementById("addTaskFab").addEventListener("click", () => {
      window.location.href = "add-task.html";
    });

    // Task filter buttons
    const showAllBtn = document.getElementById("showAll");
    const showAssignmentsBtn = document.getElementById("showAssignments");
    const showProjectsBtn = document.getElementById("showProjects");
    const showDoneBtn = document.getElementById("showDone");

    function filterTasks(filter) {
      const tasks = document.querySelectorAll("#tasksList .task-item");
      tasks.forEach(task => {
        if (filter === 'all') {
          task.style.display = 'flex';
        } else if (filter === 'assignment' && task.classList.contains('assignment') && !task.classList.contains('done')) {
          task.style.display = 'flex';
        } else if (filter === 'project' && task.classList.contains('project') && !task.classList.contains('done')) {
          task.style.display = 'flex';
        } else if (filter === 'done' && task.classList.contains('done')) {
          task.style.display = 'flex';
        } else {
          task.style.display = 'none';
        }
      });
    }

    showAllBtn.addEventListener('click', () => {
      filterTasks('all');
      document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
      showAllBtn.classList.add('active');
    });

    showAssignmentsBtn.addEventListener('click', () => {
      filterTasks('assignment');
      document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
      showAssignmentsBtn.classList.add('active');
    });

    showProjectsBtn.addEventListener('click', () => {
      filterTasks('project');
      document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
      showProjectsBtn.classList.add('active');
    });

    showDoneBtn.addEventListener('click', () => {
      filterTasks('done');
      document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
      showDoneBtn.classList.add('active');
    });
  }









    /* ═══════════════════════════════════════════════════════════════ */
    /* SETUP DATE CLICK EVENTS: Add click handlers to calendar dates */
    /* ═══════════════════════════════════════════════════════════════ */
    function setupDateClickEvents(month, year, user) {
      const datesGrid = document.getElementById('datesGrid');
      
      // Add click listener to each date cell
      datesGrid.querySelectorAll('span').forEach(s => {
        // Skip blank cells (days before month starts)
        if (!s.classList.contains('blank')) {
          s.addEventListener('click', () => {
            highlight(s);  // Highlight selected date with blue background
            // Load schedule for clicked date
            showFor(parseInt(s.textContent), month, year, user);
          });
        }
      });
    }

    /* ═══════════════════════════════════════════════════════════════ */
    /* HIGHLIGHT TODAY: Highlight and load schedule for system's today */
    /* ═══════════════════════════════════════════════════════════════ */
    function highlightToday() {
      const now = new Date();
      const datesGrid = document.getElementById('datesGrid');
      const todayNum = now.getDate();

      // Find and highlight today in the calendar grid (if visible)
      if (now.getMonth() === currentMonth && now.getFullYear() === currentYear) {
        const todaySpan = Array.from(datesGrid.children).find(ch => 
            !ch.classList.contains('blank') && parseInt(ch.textContent) === todayNum
        );
        if (todaySpan) {
            highlight(todaySpan);
        }
      }
      
      // Load schedule for system's current date
      if (auth.currentUser) {
        showFor(todayNum, now.getMonth(), now.getFullYear(), auth.currentUser);
      } else {
        console.warn("highlightToday: auth.currentUser is not available.");
      }
    }

    /* ═══════════════════════════════════════════════════════════════ */
    /* TIME FORMAT HELPER: Convert 24-hour format to 12-hour AM/PM */
    /* ═══════════════════════════════════════════════════════════════ */
    function to12HourFormat(hours, minutes) {
      const ampm = hours >= 12 ? 'PM' : 'AM';
      hours = hours % 12 || 12;
      return `${hours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
    }

    // Parse a time string like "16:00" or "4:00 PM" into 24h parts
    function parseTimeToParts(t) {
      if (!t) return null;
      const s = t.trim();
      const m = s.match(/^(\d{1,2})(?::(\d{2}))?\s*(AM|PM)?$/i);
      if (!m) return null;
      let h = parseInt(m[1], 10);
      let min = m[2] ? parseInt(m[2], 10) : 0;
      const ap = m[3] ? m[3].toUpperCase() : null;
      if (ap) {
        if (ap === 'PM' && h < 12) h += 12;
        if (ap === 'AM' && h === 12) h = 0;
      }
      return { hours: h, minutes: min };
    }

    /* ═══════════════════════════════════════════════════════════════ */
    /* SHOW SCHEDULE FOR DATE: Load classes for selected calendar date */
    /* ═══════════════════════════════════════════════════════════════ */
    /* SHOW SCHEDULE FOR DATE */
async function showFor(dayNum, month, year, user) {
  const scheduleList = document.getElementById('scheduleList');
  clearSchedule();

  if (!user || !user.uid) {
    console.error("showFor called with invalid user object or uid:", user);
    scheduleList.innerHTML = "<p style='text-align:center;color:red;'>Error: User not identified for schedule.</p>";
    return;
  }

  // Show loading text while fetching
  scheduleList.innerHTML = '<div class="tab-loading">Fetching data...</div>';

  const sel = new Date(year, month, dayNum);
  const wd = sel.toLocaleString('en-US', { weekday: 'short' });

  const q = query(
    collection(db, 'classes'),
    where("userId", "==", user.uid),
    orderBy('time')
  );

  onSnapshot(q,
    (snapshot) => {
      let found = false;
      scheduleList.innerHTML = '';

      snapshot.forEach(doc => {
        const c = doc.data();
        const classDays = c.days.split(/,\s*/).map(d => d.substring(0, 3));
        
        if (classDays.includes(wd)) {
          found = true;
          
          const timeStr = c.time || (c.startTime && c.endTime ? `${c.startTime} - ${c.endTime}` : '');
          let timeRange = timeStr;
          if (timeStr && timeStr.includes('-')) {
            const [startTime, endTime] = timeStr.split('-').map(s => s.trim());
            const sp = parseTimeToParts(startTime);
            const ep = parseTimeToParts(endTime);
            if (sp && ep) {
              timeRange = `${to12HourFormat(sp.hours, sp.minutes)} – ${to12HourFormat(ep.hours, ep.minutes)}`;
            }
          }

          const it = document.createElement('div');
          it.className = 'schedule-item';
          it.innerHTML = `
            <div class="time">${timeRange}</div>
            <div class="details">
              <h4>${c.name || 'Unnamed Class'}</h4>
              <p>${c.instructor || ''}</p>
            </div>
          `;
          scheduleList.appendChild(it);
        }
      });

      if (!found) {
        scheduleList.innerHTML = "<p style='text-align:center;color:gray;'>No classes on this day.</p>";
      }
    },
    (error) => {
      console.error("Error getting classes for showFor:", error);
      scheduleList.innerHTML = "<p style='text-align:center;color:red;'>Error loading schedule</p>";
    }
  );
}

    /* ═══════════════════════════════════════════════════════════════ */
    /* CLEAR SCHEDULE: Empty the schedule list */
    /* ═══════════════════════════════════════════════════════════════ */
    function clearSchedule() {
      const scheduleList = document.getElementById('scheduleList');
      scheduleList.innerHTML = '';
    }

    /* ═══════════════════════════════════════════════════════════════ */
    /* HIGHLIGHT: Add/remove selected-date class from calendar cells */
    /* ═══════════════════════════════════════════════════════════════ */
    function highlight(el) {
      // Remove highlight from previously selected date
      const selectedEl = document.querySelector('.selected-date');
      if (selectedEl) selectedEl.classList.remove('selected-date');
      // Add highlight to newly selected date
      el.classList.add('selected-date');
    }









    /*profile section*/
   


/* PROFILE SECTION LOGIC */
function initializeProfileSection(user) {
  if (!user) return;
  
  const userName = document.getElementById('userName');
  const userEmail = document.getElementById('userEmail');
  const userSchool = document.getElementById('userSchool');
  const userAge = document.getElementById('userAge');
  const logoutBtn = document.getElementById('logoutBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  
  if (!userName) {
    console.error("Profile elements not found");
    return;
  }

  const loadProfile = async (uid) => {
    try {
      const userDoc = await getDoc(doc(db, "users", uid));
      if (userDoc.exists()) {
        const data = userDoc.data();
        userName.textContent = data.fullName || 'Not set';
        userEmail.value = data.email || 'Not set';
        userSchool.value = data.school || 'Not set';
        userAge.value = data.age || 'Not set';

        // Load saved profile picture
        if (data.profilePicture) {
          const userPhoto = document.getElementById('userPhoto');
          if (userPhoto) userPhoto.src = `../image/${data.profilePicture}`;
        }
      } else {
        userName.textContent = "User not found";
      }
    } catch (error) {
      console.error("Error loading profile:", error);
      userName.textContent = "Error loading profile";
    }
  };

  // Load profile data
  loadProfile(user.uid);

  // Logout functionality
  if (logoutBtn) {
    logoutBtn.addEventListener('click', async () => {
      try {
        await signOut(auth);
        showNotification('Logged out successfully');
        setTimeout(() => window.location.href = 'login.html', 1000);
      } catch (error) {
        showNotification(`Logout failed: ${error.message}`);
      }
    });
  }

  // Delete account functionality
  if (deleteBtn) {
    deleteBtn.addEventListener('click', async () => {
      if (confirm('Are you sure you want to delete your account? This cannot be undone.')) {
        try {
          const user = auth.currentUser;
          if (user) {
            await deleteDoc(doc(db, "users", user.uid));
            await user.delete();
            showNotification('Account deleted successfully');
            setTimeout(() => window.location.href = 'login.html', 1000);
          }
        } catch (error) {
          showNotification(`Error deleting account: ${error.message}`);
        }
      }
    });
  }


}



    /* ═══════════════════════════════════════════════════════════════ */
    /* CHECK UPCOMING ALERTS: Notify user of classes/tasks within 2 hours */
    /* ═══════════════════════════════════════════════════════════════ */
    async function checkUpcomingAlerts(user) {
      // Guard: Verify user exists
      if (!user || !user.uid) {
        console.error("checkUpcomingAlerts: User or user.uid is invalid.");
        return;
      }
      
      const now = new Date();
      const twoHoursLater = new Date(now.getTime() + 2 * 60 * 60 * 1000);
      const nextDay = new Date(now.getTime() + 24 * 60 * 60 * 1000);

      // Query: Get all classes and tasks for this user
      const classQuery = query(collection(db, "classes"), where("userId", "==", user.uid));
      const taskQuery = query(collection(db, "tasks"), where("userId", "==", user.uid));

      let showAlert = false;
      let alertMessages = [];

      // Check for upcoming classes within 2 hours
      try {
        const classSnapshot = await getDocs(classQuery);
        classSnapshot.forEach(doc => {
          const c = doc.data();
          // Split class days and check if class is today
          const classDays = c.days.split(/,\s*/);
          const today = now.toLocaleString('en-US', { weekday: 'long' });

          if (classDays.includes(today)) {
            // Parse class start time (extract start portion before " - ")
            const startStr = c.time.split(" - ")[0];
            const [startH, startM] = startStr.split(":").map(Number);
            const classTime = new Date(now);
            classTime.setHours(startH, startM, 0, 0);

            // Alert if class starts within 2 hours
            if (classTime > now && classTime <= twoHoursLater) {
              alertMessages.push(`Upcoming class "${c.name}" starts at ${startStr}`);
              showAlert = true;
            }
          }
        });
      } catch (error) {
        console.error("Error checking upcoming classes:", error);
      }

      // Check for tasks due within 24 hours
      try {
        const taskSnapshot = await getDocs(taskQuery);
        taskSnapshot.forEach(doc => {
          const t = doc.data();
          const due = t.dueDate?.toDate ? t.dueDate.toDate() : new Date(t.dueDate);
          
          // Alert if task is due within 24 hours
          if (due > now && due <= nextDay) {
            alertMessages.push(`Task "${t.name}" is due soon (${due.toLocaleDateString()})`);
            showAlert = true;
          }
        });
      } catch (error) {
        console.error("Error checking upcoming tasks:", error);
      }

      // Show all collected alerts to user
      if (showAlert) {
        alertMessages.forEach(msg => showNotification(msg));
      }
    }



 /* -----------------------------
   MODERN DASHBOARD STATISTICS
------------------------------ */

function updateDashboard(data) {
  const {
    totalTasks,
    completedTasks,
    pendingTasks,
    totalClasses
  } = data;

  // Square Cards
  document.getElementById("statTotalTasks").textContent = totalTasks;
  document.getElementById("statCompleted").textContent = completedTasks;
  document.getElementById("statPending").textContent = pendingTasks;
  document.getElementById("statTotalClasses").textContent = totalClasses;

  // Percentages
  let taskPercent = totalTasks === 0 ? 0 : Math.round((completedTasks / totalTasks) * 100);
  let classPercent = totalClasses === 0 ? 0 : 100;

  // Circular UI
  animateCircle("progressTasks", "progressTasksValue", taskPercent);
  animateCircle("progressClasses", "progressClassesValue", classPercent);
}


/* ------------------------------
   CIRCLE ANIMATION
------------------------------ */

function animateCircle(id, textId, percent) {
  const circle = document.getElementById(id);
  const text = document.getElementById(textId);

  let start = 0;
  let end = percent;
  let speed = 10;

  let interval = setInterval(() => {
    start++;

    circle.style.background =
      `conic-gradient(var(--accent-color) ${start * 3.6}deg, rgba(255,255,255,0.2) 0deg)`;

    text.textContent = start + "%";

    if (start >= end) clearInterval(interval);
  }, speed);
}


/* ------------------------------
   FETCH STATISTICS FROM FIRESTORE
------------------------------ */

async function loadStatistics(user) {
  if (!user || !user.uid) return;

  const classesRef = query(collection(db, "classes"), where("userId", "==", user.uid));
  const tasksRef = query(collection(db, "tasks"), where("userId", "==", user.uid));

  onSnapshot(classesRef, (classSnap) => {
    onSnapshot(tasksRef, (taskSnap) => {

      const totalClasses = classSnap.size;
      const totalTasks = taskSnap.size;

      let completedTasks = 0;
      let pendingTasks = 0;

      taskSnap.forEach(doc => {
        const task = doc.data();
        task.completed ? completedTasks++ : pendingTasks++;
      });

      // Update the modern dashboard
      updateDashboard({
        totalTasks,
        completedTasks,
        pendingTasks,
        totalClasses
      });

      // Collect recent tasks (last 5 by due date)
      const allTasks = taskSnap.docs.map(doc => ({ ...doc.data(), id: doc.id }));
      const recentTasks = allTasks.sort((a, b) => {
        const aDate = a.dueDate?.toDate ? a.dueDate.toDate() : new Date(a.dueDate);
        const bDate = b.dueDate?.toDate ? b.dueDate.toDate() : new Date(b.dueDate);
        return bDate - aDate; // Most recent first
      }).slice(0, 5);

      // Collect recent classes (last 5 by creation date)
      const allClasses = classSnap.docs.map(doc => ({ ...doc.data(), id: doc.id }));
      const recentClasses = allClasses.sort((a, b) => {
        const aDate = a.createdAt ? new Date(a.createdAt) : new Date();
        const bDate = b.createdAt ? new Date(b.createdAt) : new Date();
        return bDate - aDate; // Most recent first
      }).slice(0, 5);

      // Update motivational message and activity with both tasks and classes
      updateMotivationalContent(completedTasks, totalTasks, recentTasks, recentClasses);

    });
  });
}

function updateMotivationalContent(completed, total, recentTasks = [], recentClasses = []) {
  const quoteEl = document.getElementById('dailyQuote');
  const activityListEl = document.getElementById('activityList');

  if (!quoteEl || !activityListEl) return;

  // Rotate quotes daily
  const quotes = [
    '"The only way to do great work is to love what you do." - Steve Jobs',
    '"Believe you can and you\'re halfway there." - Theodore Roosevelt',
    '"The future belongs to those who believe in the beauty of their dreams." - Eleanor Roosevelt',
    '"You miss 100% of the shots you don\'t take." - Wayne Gretzky',
    '"The best way to predict the future is to create it." - Peter Drucker'
  ];
  const today = new Date().getDate();
  quoteEl.textContent = quotes[today % quotes.length];

  // Update activity list
  activityListEl.innerHTML = '';

  // Combine and sort all recent activities (both tasks and classes)
  const allActivities = [];

  // Add tasks to activities
  recentTasks.forEach(task => {
    allActivities.push({
      type: 'task',
      data: task,
      timestamp: task.createdAt ? new Date(task.createdAt) : new Date()
    });
  });

  // Add classes to activities
  recentClasses.forEach(cls => {
    allActivities.push({
      type: 'class',
      data: cls,
      timestamp: cls.createdAt ? new Date(cls.createdAt) : new Date()
    });
  });

  // Sort by timestamp (newest first)
  allActivities.sort((a, b) => b.timestamp - a.timestamp);

  const recentActivities = allActivities.slice(0, 5); // Last 5

  if (recentActivities.length === 0) {
    activityListEl.innerHTML = '<p style="text-align: center; color: var(--subtext);">No recent activity</p>';
  } else {
    recentActivities.forEach(activity => {
      const activityItem = document.createElement('div');
      activityItem.className = 'activity-item';

      if (activity.type === 'task') {
        const task = activity.data;
        const action = task.completed ? 'Completed' : 'Added';
        const icon = task.completed ? '✅' : '➕';
        activityItem.innerHTML = `
          <div>${icon} ${action} ${task.type || 'Task'}: ${task.name}</div>
          <div class="activity-time">${activity.timestamp.toLocaleDateString()}</div>
        `;
      } else if (activity.type === 'class') {
        const cls = activity.data;
        activityItem.innerHTML = `
          <div>📚 Added Class: ${cls.name}</div>
          <div class="activity-time">${activity.timestamp.toLocaleDateString()}</div>
        `;
      }

      activityListEl.appendChild(activityItem);
    });
  }
}


// Tab switching is handled by the injected tabsbar component.


/* ═══════════════════════════════════════════════════════════════ */
/* SHOW NOTIFICATION: Display temporary toast notification to user */
/* ═══════════════════════════════════════════════════════════════ */
    function showNotification(message) {
      // Get or create notification container
      const container = document.getElementById('alertBoxContainer');
      if (!container) {
        console.error("Alert box container not found!");
        return;
      }

      // Create notification box element
      const box = document.createElement('div');
      box.textContent = message;

      // Style notification with dark theme (consistent with add forms)
      box.style.cssText = `
        background: rgba(78, 78, 78, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #e6eef8;
        font-weight: 600;
        padding: 12px 16px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        font-size: 0.95rem;
        max-width: 300px;
        animation: fadein 0.3s ease, fadeout 0.5s ease 4.5s;
        opacity: 0;
        margin-bottom: 10px;
      `;

      // Fade in notification
      setTimeout(() => box.style.opacity = 1, 10);

      // Auto-remove after 5 seconds
      setTimeout(() => {
        box.style.opacity = 0;
        setTimeout(() => {
            if (container.contains(box)) {
                container.removeChild(box);
            }
        }, 500);
      }, 5000);

      // Add to notification container
      container.appendChild(box);
    }

  </script>

  <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- LOADING SCREEN TIMER: Handle first-time load vs login redirect -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
 <script>
  const loadingScreen = document.getElementById('loadingScreen');
  // keep initial UI elements hidden; auth handler will show them when ready
  const tabBar = document.querySelector('.tab-bar');
  const chatbotFab = document.getElementById('chatbot-fab');
  const appContainer = document.querySelector('.app-container');
  if (tabBar) tabBar.style.display = 'none';
  if (chatbotFab) chatbotFab.style.display = 'none';
  if (appContainer) appContainer.style.display = 'none';

  // Record that loader was shown (prevent repeated long animations)
  if (!sessionStorage.getItem('loaderShown')) {
    sessionStorage.setItem('loaderShown', 'true');
  }

  // Fail-safe: if auth never resolves, hide loader after 8s to avoid permanent block
  const failSafe = setTimeout(() => {
    if (loadingScreen) loadingScreen.style.display = 'none';
    if (appContainer) appContainer.style.display = 'block';
    if (tabBar) tabBar.style.display = 'flex';
    if (chatbotFab) chatbotFab.style.display = 'flex';
    console.warn('Loader hidden by fail-safe timeout');
  }, 8000);

  // Expose function so auth handler can clear the timeout when it hides the loader
  window._clearLoaderFailSafe = () => clearTimeout(failSafe);
</script>

  <!-- ensure loading screen doesn't re-block UI when tabs change -->
  <script>
    (function(){
      const loading = document.getElementById('loadingScreen');
      const app = document.querySelector('.app-container');
      const tabContainer = document.getElementById('tab-bar-container');

      // Force background white (avoid accidental dark overlay from other CSS)
      if (loading) loading.style.background = 'black';

      function hideLoading() {
        // Don't auto-hide loader when tab fragment injects unless user/auth is ready.
        if (!window._authFinished && !window.auth?.currentUser) {
          // keep loader visible until auth+data finish (fail-safe will still clear after timeout)
          return;
        }

        if (loading) loading.style.display = 'none';
        if (app) app.style.display = 'block';
        const tb = document.querySelector('.tab-bar');
        if (tb) tb.style.display = 'flex';
        const fab = document.getElementById('chatbot-fab');
        if (fab) fab.style.display = 'flex';

        // clear the fail-safe timeout so it doesn't run after we intentionally hid the loader
        window._clearLoaderFailSafe?.();
      }

      // Hide when tab fragment is clicked
      tabContainer?.addEventListener('click', (e) => {
        if (e.target.closest('a, button, .tab-item, .tab-link')) {
          hideLoading();
        }
      });

      // Listen for optional custom event other code might dispatch
      document.addEventListener('tab-change', hideLoading);

      // If the tab fragment is injected, ensure loading is hidden
      const mo = new MutationObserver((mutations) => {
        if (tabContainer && tabContainer.children.length) hideLoading();
      });
      if (tabContainer) mo.observe(tabContainer, { childList: true, subtree: true });

      // Expose helper for other scripts
      window.hideLoadingScreen = hideLoading;

    })();





    (async function loadLoader() {
    try {
      const res = await fetch('./components/loader.html');
      const html = await res.text();
      const container = document.getElementById('loadingScreen');
      container.innerHTML = html;
    } catch (err) {
      console.error('Failed to load loader:', err);
    }
  })();
  </script>
  
  <!-- ═══════════════════════════════════════════════════════════════ -->
  <!-- PWA Install Script -->
  <script src="../js/pwa-install.js"></script>

  <!-- NOTIFICATION MANAGER: Handle offline push notifications -->
  <script src="../js/notification-manager.js"></script>

  <!-- CHATBOT SCRIPT: Handle FAB interaction and message sending -->
  <!-- ═══════════════════════════════════════════════════════════════ -->
  <div id="alertBoxContainer" style="position: fixed; top: 10px; right: 10px; z-index: 9999; display: flex; flex-direction: column; align-items: flex-end;"></div>
  <script type="module" src="../js/chatbot.js"></script>
  <script src="../js/script.js"></script>

</body>

</html>
